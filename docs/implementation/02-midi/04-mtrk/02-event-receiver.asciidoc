= Event Receiver

Read up on link:../../../background-information/[Inversion of Control] to understand the purpose of this step.

To implement this pattern, we need an interface-like class (i.e. only unimplemented virtual member functions) `EventReceiver` that has one member function per type of event.
Each member function will be called when the corresponding type of event is encountered in the MIDI file.
The extra data associated with the event will be provided through parameters.

For example, take the note on event.

[source,c++]
----
void<1> note_on<2>(Duration dt, Channel channel, NoteNumber note, uint8_t velocity<3>)<4>
----
<1> The return type always has to be `void`.
<2> The function's name mirrors the event type.
<3> The parameters correspond to the data associated with the event.
<4> Note the lack of `const`: we want our receiver objects to change state internally upon reception of event data.

A couple of other examples:

* `void meta(Duration dt, uint8_t type, std::unique_ptr<uint8_t[]> data, uint64_t data_size)`
* `void sysex(Duration dt, std::unique_ptr<uint8_t[]> data, uint64_t data_size)`
